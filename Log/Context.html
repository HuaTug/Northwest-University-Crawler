<div class="article">            <div class="inner">              <header class="article-header">                <h1 class="article-title" itemprop="name">Context</h1>                                <a target="_blank" rel="noopener" href="https://translate.gorm.io/project/go-gorm/zh-CN" class="article-edit-link" title="改进此页面"><i class="fa fa-pencil"></i></a>                              </header>              <div class="article-content" itemprop="articleBody">                <html><head></head><body><p>GORM 通过 <code>WithContext</code> 方法提供了 Context 支持</p><h2 id="单会话模式" class="article-heading"><a href="#单会话模式" class="headerlink" title="单会话模式"></a>单会话模式<a class="article-anchor" href="#单会话模式" aria-hidden="true"></a></h2><p>单会话模式通常被用于执行单次操作</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.WithContext(ctx).Find(&amp;users)</span><br></pre></td></tr></tbody></table></figure><h2 id="持续会话模式" class="article-heading"><a href="#持续会话模式" class="headerlink" title="持续会话模式"></a>持续会话模式<a class="article-anchor" href="#持续会话模式" aria-hidden="true"></a></h2><p>持续会话模式通常被用于执行一系列操作，例如：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">tx := db.WithContext(ctx)</span><br><span class="line">tx.First(&amp;user, <span class="number">1</span>)</span><br><span class="line">tx.Model(&amp;user).Update(<span class="string">"role"</span>, <span class="string">"admin"</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="Context-超时" class="article-heading"><a href="#Context-超时" class="headerlink" title="Context 超时"></a>Context 超时<a class="article-anchor" href="#Context-超时" aria-hidden="true"></a></h2><p>对于长 Sql 查询，你可以传入一个带超时的 context 给 <code>db.WithContext</code> 来设置超时时间，例如：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">2</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">db.WithContext(ctx).Find(&amp;users)</span><br></pre></td></tr></tbody></table></figure><h2 id="Hooks-x2F-Callbacks-中的-Context" class="article-heading"><a href="#Hooks-x2F-Callbacks-中的-Context" class="headerlink" title="Hooks/Callbacks 中的 Context"></a>Hooks/Callbacks 中的 Context<a class="article-anchor" href="#Hooks-x2F-Callbacks-中的-Context" aria-hidden="true"></a></h2><p>您可以从当前 <code>Statement</code>中访问 <code>Context</code> 对象，例如︰</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> BeforeCreate(tx *gorm.DB) (err <span class="type">error</span>) {</span><br><span class="line">  ctx := tx.Statement.Context</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Chi-中间件示例" class="article-heading"><a href="#Chi-中间件示例" class="headerlink" title="Chi 中间件示例"></a>Chi 中间件示例<a class="article-anchor" href="#Chi-中间件示例" aria-hidden="true"></a></h2><p>在处理 API 请求时持续会话模式会比较有用。例如，您可以在中间件中为 <code>*gorm.DB</code> 设置超时 Context，然后使用 <code>*gorm.DB</code> 处理所有请求</p><p>下面是一个 Chi 中间件的示例：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetDBMiddleware</span><span class="params">(next http.Handler)</span></span> http.Handler {</span><br><span class="line">  <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    timeoutContext, _ := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">    ctx := context.WithValue(r.Context(), <span class="string">"DB"</span>, db.WithContext(timeoutContext))</span><br><span class="line">    next.ServeHTTP(w, r.WithContext(ctx))</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">r := chi.NewRouter()</span><br><span class="line">r.Use(SetDBMiddleware)</span><br><span class="line"></span><br><span class="line">r.Get(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">  db, ok := ctx.Value(<span class="string">"DB"</span>).(*gorm.DB)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> users []User</span><br><span class="line">  db.Find(&amp;users)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你的其他 DB 操作...</span></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">r.Get(<span class="string">"/user"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">  db, ok := ctx.Value(<span class="string">"DB"</span>).(*gorm.DB)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> user User</span><br><span class="line">  db.First(&amp;user)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你的其他 DB 操作...</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><blockquote class="note undefined"><p><strong>注意</strong> 通过 <code>WithContext</code> 设置的 <code>Context</code> 是线程安全的，参考<a href="session.html">会话</a>获取详情</p></blockquote><h2 id="Logger" class="article-heading"><a href="#Logger" class="headerlink" title="Logger"></a>Logger<a class="article-anchor" href="#Logger" aria-hidden="true"></a></h2><p>Logger 也可以支持 <code>Context</code>，可用于日志追踪，查看 <a href="logger.html">Logger</a> 获取详情</p></body></html>              </div>