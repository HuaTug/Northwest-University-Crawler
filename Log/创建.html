<div class="article">            <div class="inner">              <header class="article-header">                <h1 class="article-title" itemprop="name">创建</h1>                                <a target="_blank" rel="noopener" href="https://translate.gorm.io/project/go-gorm/zh-CN" class="article-edit-link" title="改进此页面"><i class="fa fa-pencil"></i></a>                              </header>              <div class="article-content" itemprop="articleBody">                <html><head></head><body><h2 id="创建记录" class="article-heading"><a href="#创建记录" class="headerlink" title="创建记录"></a>创建记录<a class="article-anchor" href="#创建记录" aria-hidden="true"></a></h2><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">user := User{Name: <span class="string">"Jinzhu"</span>, Age: <span class="number">18</span>, Birthday: time.Now()}</span><br><span class="line"></span><br><span class="line">result := db.Create(&amp;user) <span class="comment">// 通过数据的指针来创建</span></span><br><span class="line"></span><br><span class="line">user.ID             <span class="comment">// 返回插入数据的主键</span></span><br><span class="line">result.Error        <span class="comment">// 返回 error</span></span><br><span class="line">result.RowsAffected <span class="comment">// 返回插入记录的条数</span></span><br></pre></td></tr></tbody></table></figure><p>我们还可以使用 <code>Create()</code> 创建多项记录：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">users := []*User{</span><br><span class="line">    User{Name: <span class="string">"Jinzhu"</span>, Age: <span class="number">18</span>, Birthday: time.Now()},</span><br><span class="line">    User{Name: <span class="string">"Jackson"</span>, Age: <span class="number">19</span>, Birthday: time.Now()},</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">result := db.Create(users) <span class="comment">// 传递切片以插入多行数据</span></span><br><span class="line"></span><br><span class="line">result.Error        <span class="comment">// 返回 error</span></span><br><span class="line">result.RowsAffected <span class="comment">// 返回插入记录的条数</span></span><br></pre></td></tr></tbody></table></figure><blockquote class="note warn"><p><strong>NOTE</strong> 你无法向 ‘create’ 传递结构体，所以你应该传入数据的指针.</p></blockquote><h2 id="用指定的字段创建记录" class="article-heading"><a href="#用指定的字段创建记录" class="headerlink" title="用指定的字段创建记录"></a>用指定的字段创建记录<a class="article-anchor" href="#用指定的字段创建记录" aria-hidden="true"></a></h2><p>创建记录并为指定字段赋值。</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Select(<span class="string">"Name"</span>, <span class="string">"Age"</span>, <span class="string">"CreatedAt"</span>).Create(&amp;user)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`age`,`created_at`) VALUES ("jinzhu", 18, "2020-07-04 11:05:21.775")</span></span><br></pre></td></tr></tbody></table></figure><p>创建记录并忽略传递给 ‘Omit’ 的字段值</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Omit(<span class="string">"Name"</span>, <span class="string">"Age"</span>, <span class="string">"CreatedAt"</span>).Create(&amp;user)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`birthday`,`updated_at`) VALUES ("2020-01-01 00:00:00.000", "2020-07-04 11:05:21.775")</span></span><br></pre></td></tr></tbody></table></figure><h2 id="批量插入" class="article-heading"><a href="#批量插入" class="headerlink" title="批量插入"></a><span id="batch_insert">批量插入</span><a class="article-anchor" href="#批量插入" aria-hidden="true"></a></h2><p>要高效地插入大量记录，请将切片传递给<code>Create</code>方法。 GORM will generate a single SQL statement to insert all the data and backfill primary key values, hook methods will be invoked too. 当记录可以分成多个批处理时，它将开始一个 <strong>交易</strong>。</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> users = []User{{Name: <span class="string">"jinzhu1"</span>}, {Name: <span class="string">"jinzhu2"</span>}, {Name: <span class="string">"jinzhu3"</span>}}</span><br><span class="line">db.Create(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> users {</span><br><span class="line">  user.ID <span class="comment">// 1,2,3</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>You can specify batch size when creating with <code>CreateInBatches</code>, e.g:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> users = []User{{Name: <span class="string">"jinzhu_1"</span>}, ...., {Name: <span class="string">"jinzhu_10000"</span>}}</span><br><span class="line"></span><br><span class="line"><span class="comment">// batch size 100</span></span><br><span class="line">db.CreateInBatches(users, <span class="number">100</span>)</span><br></pre></td></tr></tbody></table></figure><p>Batch Insert is also supported when using <a href="#upsert">Upsert</a> and <a href="#create_with_associations">Create With Associations</a></p><blockquote class="note warn"><p><strong>NOTE</strong> initialize GORM with <code>CreateBatchSize</code> option, all <code>INSERT</code> will respect this option when creating record &amp; associations</p></blockquote><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db, err := gorm.Open(sqlite.Open(<span class="string">"gorm.db"</span>), &amp;gorm.Config{</span><br><span class="line">  CreateBatchSize: <span class="number">1000</span>,</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">db := db.Session(&amp;gorm.Session{CreateBatchSize: <span class="number">1000</span>})</span><br><span class="line"></span><br><span class="line">users = [<span class="number">5000</span>]User{{Name: <span class="string">"jinzhu"</span>, Pets: []Pet{pet1, pet2, pet3}}...}</span><br><span class="line"></span><br><span class="line">db.Create(&amp;users)</span><br><span class="line"><span class="comment">// INSERT INTO users xxx (5 batches)</span></span><br><span class="line"><span class="comment">// INSERT INTO pets xxx (15 batches)</span></span><br></pre></td></tr></tbody></table></figure><h2 id="创建钩子" class="article-heading"><a href="#创建钩子" class="headerlink" title="创建钩子"></a>创建钩子<a class="article-anchor" href="#创建钩子" aria-hidden="true"></a></h2><p>GORM allows user defined hooks to be implemented for <code>BeforeSave</code>, <code>BeforeCreate</code>, <code>AfterSave</code>, <code>AfterCreate</code>.  These hook method will be called when creating a record, refer <a href="hooks.html">Hooks</a> for details on the lifecycle</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> BeforeCreate(tx *gorm.DB) (err <span class="type">error</span>) {</span><br><span class="line">  u.UUID = uuid.New()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> u.Role == <span class="string">"admin"</span> {</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"invalid role"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>If you want to skip <code>Hooks</code> methods, you can use the <code>SkipHooks</code> session mode, for example:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">DB.Session(&amp;gorm.Session{SkipHooks: <span class="literal">true</span>}).Create(&amp;user)</span><br><span class="line"></span><br><span class="line">DB.Session(&amp;gorm.Session{SkipHooks: <span class="literal">true</span>}).Create(&amp;users)</span><br><span class="line"></span><br><span class="line">DB.Session(&amp;gorm.Session{SkipHooks: <span class="literal">true</span>}).CreateInBatches(users, <span class="number">100</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="根据-Map-创建" class="article-heading"><a href="#根据-Map-创建" class="headerlink" title="根据 Map 创建"></a>根据 Map 创建<a class="article-anchor" href="#根据-Map-创建" aria-hidden="true"></a></h2><p>GORM supports create from <code>map[string]interface{}</code> and <code>[]map[string]interface{}{}</code>, e.g:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Model(&amp;User{}).Create(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">  <span class="string">"Name"</span>: <span class="string">"jinzhu"</span>, <span class="string">"Age"</span>: <span class="number">18</span>,</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// batch insert from `[]map[string]interface{}{}`</span></span><br><span class="line">db.Model(&amp;User{}).Create([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">  {<span class="string">"Name"</span>: <span class="string">"jinzhu_1"</span>, <span class="string">"Age"</span>: <span class="number">18</span>},</span><br><span class="line">  {<span class="string">"Name"</span>: <span class="string">"jinzhu_2"</span>, <span class="string">"Age"</span>: <span class="number">20</span>},</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><blockquote class="note warn"><p><strong>NOTE</strong> When creating from map, hooks won’t be invoked, associations won’t be saved and primary key values won’t be back filled</p></blockquote><h2 id="使用-SQL-表达式、Context-Valuer-创建记录" class="article-heading"><a href="#使用-SQL-表达式、Context-Valuer-创建记录" class="headerlink" title="使用 SQL 表达式、Context Valuer 创建记录"></a><span id="create_from_sql_expr">使用 SQL 表达式、Context Valuer 创建记录</span><a class="article-anchor" href="#使用-SQL-表达式、Context-Valuer-创建记录" aria-hidden="true"></a></h2><p>GORM allows insert data with SQL expression, there are two ways to achieve this goal, create from <code>map[string]interface{}</code> or <a href="data_types.html#gorm_valuer_interface">Customized Data Types</a>, for example:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Create from map</span></span><br><span class="line">db.Model(User{}).Create(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">  <span class="string">"Name"</span>: <span class="string">"jinzhu"</span>,</span><br><span class="line">  <span class="string">"Location"</span>: clause.Expr{SQL: <span class="string">"ST_PointFromText(?)"</span>, Vars: []<span class="keyword">interface</span>{}{<span class="string">"POINT(100 100)"</span>}},</span><br><span class="line">})</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`location`) VALUES ("jinzhu",ST_PointFromText("POINT(100 100)"));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create from customized data type</span></span><br><span class="line"><span class="keyword">type</span> Location <span class="keyword">struct</span> {</span><br><span class="line">    X, Y <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scan implements the sql.Scanner interface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(loc *Location)</span></span> Scan(v <span class="keyword">interface</span>{}) <span class="type">error</span> {</span><br><span class="line">  <span class="comment">// Scan a value into struct from database driver</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(loc Location)</span></span> GormDataType() <span class="type">string</span> {</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"geometry"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(loc Location)</span></span> GormValue(ctx context.Context, db *gorm.DB) clause.Expr {</span><br><span class="line">  <span class="keyword">return</span> clause.Expr{</span><br><span class="line">    SQL:  <span class="string">"ST_PointFromText(?)"</span>,</span><br><span class="line">    Vars: []<span class="keyword">interface</span>{}{fmt.Sprintf(<span class="string">"POINT(%d %d)"</span>, loc.X, loc.Y)},</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">  Name     <span class="type">string</span></span><br><span class="line">  Location Location</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">db.Create(&amp;User{</span><br><span class="line">  Name:     <span class="string">"jinzhu"</span>,</span><br><span class="line">  Location: Location{X: <span class="number">100</span>, Y: <span class="number">100</span>},</span><br><span class="line">})</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`location`) VALUES ("jinzhu",ST_PointFromText("POINT(100 100)"))</span></span><br></pre></td></tr></tbody></table></figure><h2 id="高级选项" class="article-heading"><a href="#高级选项" class="headerlink" title="高级选项"></a>高级选项<a class="article-anchor" href="#高级选项" aria-hidden="true"></a></h2><h3 id="关联创建" class="article-heading"><a href="#关联创建" class="headerlink" title="关联创建"></a><span id="create_with_associations">关联创建</span><a class="article-anchor" href="#关联创建" aria-hidden="true"></a></h3><p>When creating some data with associations, if its associations value is not zero-value, those associations will be upserted, and its <code>Hooks</code> methods will be invoked.</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CreditCard <span class="keyword">struct</span> {</span><br><span class="line">  gorm.Model</span><br><span class="line">  Number   <span class="type">string</span></span><br><span class="line">  UserID   <span class="type">uint</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name       <span class="type">string</span></span><br><span class="line">  CreditCard CreditCard</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">db.Create(&amp;User{</span><br><span class="line">  Name: <span class="string">"jinzhu"</span>,</span><br><span class="line">  CreditCard: CreditCard{Number: <span class="string">"411111111111"</span>}</span><br><span class="line">})</span><br><span class="line"><span class="comment">// INSERT INTO `users` ...</span></span><br><span class="line"><span class="comment">// INSERT INTO `credit_cards` ...</span></span><br></pre></td></tr></tbody></table></figure><p>You can skip saving associations with <code>Select</code>, <code>Omit</code>, for example:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Omit(<span class="string">"CreditCard"</span>).Create(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// skip all associations</span></span><br><span class="line">db.Omit(clause.Associations).Create(&amp;user)</span><br></pre></td></tr></tbody></table></figure><h3 id="默认值" class="article-heading"><a href="#默认值" class="headerlink" title="默认值"></a><span id="default_values">默认值</span><a class="article-anchor" href="#默认值" aria-hidden="true"></a></h3><p>You can define default values for fields with tag <code>default</code>, for example:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">  ID   <span class="type">int64</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:"default:galeone"`</span></span><br><span class="line">  Age  <span class="type">int64</span>  <span class="string">`gorm:"default:18"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Then the default value <em>will be used</em> when inserting into the database for <a target="_blank" rel="noopener" href="https://tour.golang.org/basics/12">zero-value</a> fields</p><blockquote class="note warn"><p><strong>NOTE</strong> Any zero value like <code>0</code>, <code>''</code>, <code>false</code> won’t be saved into the database for those fields defined default value, you might want to use pointer type or Scanner/Valuer to avoid this, for example:</p></blockquote><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age  *<span class="type">int</span>           <span class="string">`gorm:"default:18"`</span></span><br><span class="line">  Active sql.NullBool <span class="string">`gorm:"default:true"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote class="note warn"><p><strong>NOTE</strong> You have to setup the <code>default</code> tag for fields having default or virtual/generated value in database, if you want to skip a default value definition when migrating, you could use <code>default:(-)</code>, for example:</p></blockquote><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">  ID        <span class="type">string</span> <span class="string">`gorm:"default:uuid_generate_v3()"`</span> <span class="comment">// db func</span></span><br><span class="line">  FirstName <span class="type">string</span></span><br><span class="line">  LastName  <span class="type">string</span></span><br><span class="line">  Age       <span class="type">uint8</span></span><br><span class="line">  FullName  <span class="type">string</span> <span class="string">`gorm:"-&gt;;type:GENERATED ALWAYS AS (concat(firstname,' ',lastname));default:(-);"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>When using virtual/generated value, you might need to disable its creating/updating permission, check out <a href="models.html#field_permission">Field-Level Permission</a></p><h3 id="Upsert-及冲突" class="article-heading"><a href="#Upsert-及冲突" class="headerlink" title="Upsert 及冲突"></a><span id="upsert">Upsert 及冲突</span><a class="article-anchor" href="#Upsert-及冲突" aria-hidden="true"></a></h3><p>GORM provides compatible Upsert support for different databases</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"gorm.io/gorm/clause"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Do nothing on conflict</span></span><br><span class="line">db.Clauses(clause.OnConflict{DoNothing: <span class="literal">true</span>}).Create(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update columns to default value on `id` conflict</span></span><br><span class="line">db.Clauses(clause.OnConflict{</span><br><span class="line">  Columns:   []clause.Column{{Name: <span class="string">"id"</span>}},</span><br><span class="line">  DoUpdates: clause.Assignments(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{<span class="string">"role"</span>: <span class="string">"user"</span>}),</span><br><span class="line">}).Create(&amp;users)</span><br><span class="line"><span class="comment">// MERGE INTO "users" USING *** WHEN NOT MATCHED THEN INSERT *** WHEN MATCHED THEN UPDATE SET ***; SQL Server</span></span><br><span class="line"><span class="comment">// INSERT INTO `users` *** ON DUPLICATE KEY UPDATE ***; MySQL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use SQL expression</span></span><br><span class="line">db.Clauses(clause.OnConflict{</span><br><span class="line">  Columns:   []clause.Column{{Name: <span class="string">"id"</span>}},</span><br><span class="line">  DoUpdates: clause.Assignments(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{<span class="string">"count"</span>: gorm.Expr(<span class="string">"GREATEST(count, VALUES(count))"</span>)}),</span><br><span class="line">}).Create(&amp;users)</span><br><span class="line"><span class="comment">// INSERT INTO `users` *** ON DUPLICATE KEY UPDATE `count`=GREATEST(count, VALUES(count));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update columns to new value on `id` conflict</span></span><br><span class="line">db.Clauses(clause.OnConflict{</span><br><span class="line">  Columns:   []clause.Column{{Name: <span class="string">"id"</span>}},</span><br><span class="line">  DoUpdates: clause.AssignmentColumns([]<span class="type">string</span>{<span class="string">"name"</span>, <span class="string">"age"</span>}),</span><br><span class="line">}).Create(&amp;users)</span><br><span class="line"><span class="comment">// MERGE INTO "users" USING *** WHEN NOT MATCHED THEN INSERT *** WHEN MATCHED THEN UPDATE SET "name"="excluded"."name"; SQL Server</span></span><br><span class="line"><span class="comment">// INSERT INTO "users" *** ON CONFLICT ("id") DO UPDATE SET "name"="excluded"."name", "age"="excluded"."age"; PostgreSQL</span></span><br><span class="line"><span class="comment">// INSERT INTO `users` *** ON DUPLICATE KEY UPDATE `name`=VALUES(name),`age`=VALUES(age); MySQL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update all columns to new value on conflict except primary keys and those columns having default values from sql func</span></span><br><span class="line">db.Clauses(clause.OnConflict{</span><br><span class="line">  UpdateAll: <span class="literal">true</span>,</span><br><span class="line">}).Create(&amp;users)</span><br><span class="line"><span class="comment">// INSERT INTO "users" *** ON CONFLICT ("id") DO UPDATE SET "name"="excluded"."name", "age"="excluded"."age", ...;</span></span><br><span class="line"><span class="comment">// INSERT INTO `users` *** ON DUPLICATE KEY UPDATE `name`=VALUES(name),`age`=VALUES(age), ...; MySQL</span></span><br></pre></td></tr></tbody></table></figure><p>Also checkout <code>FirstOrInit</code>, <code>FirstOrCreate</code> on <a href="advanced_query.html">Advanced Query</a></p><p>Checkout <a href="sql_builder.html">Raw SQL and SQL Builder</a> for more details</p></body></html>              </div>