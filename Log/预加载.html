<div class="article">            <div class="inner">              <header class="article-header">                <h1 class="article-title" itemprop="name">预加载</h1>                                <a target="_blank" rel="noopener" href="https://translate.gorm.io/project/go-gorm/zh-CN" class="article-edit-link" title="改进此页面"><i class="fa fa-pencil"></i></a>                              </header>              <div class="article-content" itemprop="articleBody">                <html><head></head><body><h2 id="预加载示例" class="article-heading"><a href="#预加载示例" class="headerlink" title="预加载示例"></a>预加载示例<a class="article-anchor" href="#预加载示例" aria-hidden="true"></a></h2><p>GORM允许使用 <code>Preload</code>通过多个SQL中来直接加载关系, 例如：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">  gorm.Model</span><br><span class="line">  Username <span class="type">string</span></span><br><span class="line">  Orders   []Order</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> {</span><br><span class="line">  gorm.Model</span><br><span class="line">  UserID <span class="type">uint</span></span><br><span class="line">  Price  <span class="type">float64</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找 user 时预加载相关 Order</span></span><br><span class="line">db.Preload(<span class="string">"Orders"</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users;</span></span><br><span class="line"><span class="comment">// SELECT * FROM orders WHERE user_id IN (1,2,3,4);</span></span><br><span class="line"></span><br><span class="line">db.Preload(<span class="string">"Orders"</span>).Preload(<span class="string">"Profile"</span>).Preload(<span class="string">"Role"</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users;</span></span><br><span class="line"><span class="comment">// SELECT * FROM orders WHERE user_id IN (1,2,3,4); // has many</span></span><br><span class="line"><span class="comment">// SELECT * FROM profiles WHERE user_id IN (1,2,3,4); // has one</span></span><br><span class="line"><span class="comment">// SELECT * FROM roles WHERE id IN (4,5,6); // belongs to</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Joins-预加载" class="article-heading"><a href="#Joins-预加载" class="headerlink" title="Joins 预加载"></a>Joins 预加载<a class="article-anchor" href="#Joins-预加载" aria-hidden="true"></a></h2><p><code>Preload</code> loads the association data in a separate query, <code>Join Preload</code> will loads association data using left join, for example:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Joins(<span class="string">"Company"</span>).Joins(<span class="string">"Manager"</span>).Joins(<span class="string">"Account"</span>).First(&amp;user, <span class="number">1</span>)</span><br><span class="line">db.Joins(<span class="string">"Company"</span>).Joins(<span class="string">"Manager"</span>).Joins(<span class="string">"Account"</span>).First(&amp;user, <span class="string">"users.name = ?"</span>, <span class="string">"jinzhu"</span>)</span><br><span class="line">db.Joins(<span class="string">"Company"</span>).Joins(<span class="string">"Manager"</span>).Joins(<span class="string">"Account"</span>).Find(&amp;users, <span class="string">"users.id IN ?"</span>, []<span class="type">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>})</span><br></pre></td></tr></tbody></table></figure><p>带条件的 Join</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Joins(<span class="string">"Company"</span>, DB.Where(&amp;Company{Alive: <span class="literal">true</span>})).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT `users`.`id`,`users`.`name`,`users`.`age`,`Company`.`id` AS `Company__id`,`Company`.`name` AS `Company__name` FROM `users` LEFT JOIN `companies` AS `Company` ON `users`.`company_id` = `Company`.`id` AND `Company`.`alive` = true;</span></span><br></pre></td></tr></tbody></table></figure><p>Join nested model</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Joins(<span class="string">"Manager"</span>).Joins(<span class="string">"Manager.Company"</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT "users"."id","users"."created_at","users"."updated_at","users"."deleted_at","users"."name","users"."age","users"."birthday","users"."company_id","users"."manager_id","users"."active","Manager"."id" AS "Manager__id","Manager"."created_at" AS "Manager__created_at","Manager"."updated_at" AS "Manager__updated_at","Manager"."deleted_at" AS "Manager__deleted_at","Manager"."name" AS "Manager__name","Manager"."age" AS "Manager__age","Manager"."birthday" AS "Manager__birthday","Manager"."company_id" AS "Manager__company_id","Manager"."manager_id" AS "Manager__manager_id","Manager"."active" AS "Manager__active","Manager__Company"."id" AS "Manager__Company__id","Manager__Company"."name" AS "Manager__Company__name" FROM "users" LEFT JOIN "users" "Manager" ON "users"."manager_id" = "Manager"."id" AND "Manager"."deleted_at" IS NULL LEFT JOIN "companies" "Manager__Company" ON "Manager"."company_id" = "Manager__Company"."id" WHERE "users"."deleted_at" IS NULL</span></span><br></pre></td></tr></tbody></table></figure><blockquote class="note warn"><p><strong>NOTE</strong> <code>Join Preload</code> works with one-to-one relation, e.g: <code>has one</code>, <code>belongs to</code></p></blockquote><h2 id="预加载全部" class="article-heading"><a href="#预加载全部" class="headerlink" title="预加载全部"></a>预加载全部<a class="article-anchor" href="#预加载全部" aria-hidden="true"></a></h2><p><code>clause.Associations</code> can work with <code>Preload</code> similar like <code>Select</code> when creating/updating, you can use it to <code>Preload</code> all associations, for example:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name       <span class="type">string</span></span><br><span class="line">  CompanyID  <span class="type">uint</span></span><br><span class="line">  Company    Company</span><br><span class="line">  Role       Role</span><br><span class="line">  Orders     []Order</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">db.Preload(clause.Associations).Find(&amp;users)</span><br></pre></td></tr></tbody></table></figure><p><code>clause.Associations</code> won’t preload nested associations, but you can use it with <a href="#nested_preloading">Nested Preloading</a> together, e.g:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Preload(<span class="string">"Orders.OrderItems.Product"</span>).Preload(clause.Associations).Find(&amp;users)</span><br></pre></td></tr></tbody></table></figure><h2 id="条件预加载" class="article-heading"><a href="#条件预加载" class="headerlink" title="条件预加载"></a>条件预加载<a class="article-anchor" href="#条件预加载" aria-hidden="true"></a></h2><p>GORM allows Preload associations with conditions, it works similar to <a href="query.html#inline_conditions">Inline Conditions</a></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Preload Orders with conditions</span></span><br><span class="line">db.Preload(<span class="string">"Orders"</span>, <span class="string">"state NOT IN (?)"</span>, <span class="string">"cancelled"</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users;</span></span><br><span class="line"><span class="comment">// SELECT * FROM orders WHERE user_id IN (1,2,3,4) AND state NOT IN ('cancelled');</span></span><br><span class="line"></span><br><span class="line">db.Where(<span class="string">"state = ?"</span>, <span class="string">"active"</span>).Preload(<span class="string">"Orders"</span>, <span class="string">"state NOT IN (?)"</span>, <span class="string">"cancelled"</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE state = 'active';</span></span><br><span class="line"><span class="comment">// SELECT * FROM orders WHERE user_id IN (1,2) AND state NOT IN ('cancelled');</span></span><br></pre></td></tr></tbody></table></figure><h2 id="自定义预加载-SQL" class="article-heading"><a href="#自定义预加载-SQL" class="headerlink" title="自定义预加载 SQL"></a>自定义预加载 SQL<a class="article-anchor" href="#自定义预加载-SQL" aria-hidden="true"></a></h2><p>You are able to custom preloading SQL by passing in <code>func(db *gorm.DB) *gorm.DB</code>, for example:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Preload(<span class="string">"Orders"</span>, <span class="function"><span class="keyword">func</span><span class="params">(db *gorm.DB)</span></span> *gorm.DB {</span><br><span class="line">  <span class="keyword">return</span> db.Order(<span class="string">"orders.amount DESC"</span>)</span><br><span class="line">}).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users;</span></span><br><span class="line"><span class="comment">// SELECT * FROM orders WHERE user_id IN (1,2,3,4) order by orders.amount DESC;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="嵌套预加载" class="article-heading"><a href="#嵌套预加载" class="headerlink" title="嵌套预加载"></a><span id="nested_preloading">嵌套预加载</span><a class="article-anchor" href="#嵌套预加载" aria-hidden="true"></a></h2><p>GORM supports nested preloading, for example:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Preload(<span class="string">"Orders.OrderItems.Product"</span>).Preload(<span class="string">"CreditCard"</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Customize Preload conditions for `Orders`</span></span><br><span class="line"><span class="comment">// And GORM won't preload unmatched order's OrderItems then</span></span><br><span class="line">db.Preload(<span class="string">"Orders"</span>, <span class="string">"state = ?"</span>, <span class="string">"paid"</span>).Preload(<span class="string">"Orders.OrderItems"</span>).Find(&amp;users)</span><br></pre></td></tr></tbody></table></figure><h2 id="Embedded-Preloading" class="article-heading"><a href="#Embedded-Preloading" class="headerlink" title="Embedded Preloading"></a><span id="embedded_preloading">Embedded Preloading</span><a class="article-anchor" href="#Embedded-Preloading" aria-hidden="true"></a></h2><p>Embedded Preloading is used for <a href="models.html#embedded_struct">Embedded Struct</a>, especially the same struct. The syntax for Embedded Preloading is similar to Nested Preloading, they are divided by dot.</p><p>For example:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> {</span><br><span class="line">    CountryID <span class="type">int</span></span><br><span class="line">    Country   Country</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Org <span class="keyword">struct</span> {</span><br><span class="line">    PostalAddress   Address <span class="string">`gorm:"embedded;embeddedPrefix:postal_address_"`</span></span><br><span class="line">    VisitingAddress Address <span class="string">`gorm:"embedded;embeddedPrefix:visiting_address_"`</span></span><br><span class="line">    Address         <span class="keyword">struct</span> {</span><br><span class="line">        ID <span class="type">int</span></span><br><span class="line">        Address</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only preload Org.Address and Org.Address.Country</span></span><br><span class="line">db.Preload(<span class="string">"Address.Country"</span>)  <span class="comment">// "Address" is has_one, "Country" is belongs_to (nested association)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Only preload Org.VisitingAddress</span></span><br><span class="line">db.Preload(<span class="string">"PostalAddress.Country"</span>) <span class="comment">// "PostalAddress.Country" is belongs_to (embedded association)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Only preload Org.NestedAddress</span></span><br><span class="line">db.Preload(<span class="string">"NestedAddress.Address.Country"</span>) <span class="comment">// "NestedAddress.Address.Country" is belongs_to (embedded association)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// All preloaded include "Address" but exclude "Address.Country", because it won't preload nested associations.</span></span><br><span class="line">db.Preload(clause.Associations)</span><br></pre></td></tr></tbody></table></figure><p>We can omit embedded part when there is no ambiguity.</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> {</span><br><span class="line">    CountryID <span class="type">int</span></span><br><span class="line">    Country   Country</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Org <span class="keyword">struct</span> {</span><br><span class="line">    Address Address <span class="string">`gorm:"embedded"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">db.Preload(<span class="string">"Address.Country"</span>)</span><br><span class="line">db.Preload(<span class="string">"Country"</span>) <span class="comment">// omit "Address" because there is no ambiguity</span></span><br></pre></td></tr></tbody></table></figure><blockquote class="note warn"><p><strong>NOTE</strong> <code>Embedded Preload</code> only works with <code>belongs to</code> relation. Values of other relations are the same in database, we can’t distinguish them.</p></blockquote></body></html>              </div>